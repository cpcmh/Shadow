<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>🌇 그림자 + 보도 교차 지도</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
html,body,#map{height:100%;margin:0;padding:0;}
.blur-shadow{filter:blur(3px);opacity:0.45;}
#panel{
  position:absolute;top:10px;left:10px;z-index:9999;
  background:rgba(255,255,255,0.95);
  padding:8px 12px;border-radius:12px;
  box-shadow:0 2px 6px rgba(0,0,0,0.25);
  font-size:14px;max-width:90vw;
}
#timeControl {
  position: absolute;
  top: 10px;
  right: 10px;
  z-index: 10000;
  background: rgba(255, 255, 255, 0.95);
  padding: 8px 12px;
  border-radius: 12px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  font-size: 14px;
  display: flex;
  gap: 5px;
  flex-wrap: wrap;
}
#timePicker { font-size: 14px; padding: 2px; min-width: 100px; }
#nowBtn { font-size: 13px; padding: 3px 6px; cursor: pointer; }
</style>
</head>
<body>
<div id="map"></div>
<div id="panel">🛰️ 지도 불러오는 중...</div>

<!-- 🕒 시간 조절 UI -->
<div id="timeControl">
  <label for="timePicker">시간:</label>
  <input type="time" id="timePicker" step="300">
  <button id="nowBtn">지금</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<script>
const panel = document.getElementById('panel');
const timePicker = document.getElementById('timePicker');
const nowBtn = document.getElementById('nowBtn');

const DEFAULT_LOC = [37.5665, 126.9780];
let myLocation = null;
let currentDate = new Date();

const map = L.map('map', { zoomControl: true });
map.setView(DEFAULT_LOC, 16);

L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap, Carto'
}).addTo(map);

const shadowLayer = L.layerGroup().addTo(map);
const footwayLayer = L.layerGroup().addTo(map);

// ☀️ 태양 위치 계산
function sunAngles(date, lat, lon){
  const p = SunCalc.getPosition(date, lat, lon);
  return { az: (180 + p.azimuth * 180/Math.PI)%360, alt: p.altitude*180/Math.PI };
}

// 🏢 기본 높이 추정
function estimateHeight(tags={}){
  if(tags.height) return parseFloat(tags.height);
  if(tags["building:levels"]) return parseFloat(tags["building:levels"])*3;
  if(tags.amenity === 'school') return 20;
  if(tags.landuse === 'residential') return 50;
  return 12;
}

// 🏢 그림자 계산
function computeShadows(polys, az, alt){
  if(alt<=0) return [];
  const tanAlt = Math.tan(alt*Math.PI/180);
  const dir = (az+180)%360;
  const out=[];
  for(const f of polys){
    const h = f.properties.height || 12;
    try {
      out.push(turf.transformTranslate(f, h/tanAlt/1000, dir, {units:'kilometers'}));
    } catch(e){
      console.error('Shadow projection error', e);
    }
  }
  return out;
}

// 🧭 Overpass 호출
async function fetchOSM(bounds){
  const s=bounds.getSouth(), w=bounds.getWest(), n=bounds.getNorth(), e=bounds.getEast();
  const q = `
  [out:json][timeout:15];
  (
    way["building"](${s},${w},${n},${e});
    way["landuse"~"residential|commercial"](${s},${w},${n},${e});
    way["amenity"="school"](${s},${w},${n},${e});
    way["highway"~"footway|pedestrian"](${s},${w},${n},${e});
  );
  out body; >; out skel qt;
  `;
  const controller = new AbortController();
  const timeout = setTimeout(()=>controller.abort(), 15000);
  const res = await fetch('https://overpass-api.de/api/interpreter',{method:'POST',body:q,signal:controller.signal});
  clearTimeout(timeout);
  if(!res.ok) throw new Error('Overpass API 오류');
  return res.json();
}

let footwayFeatures = [];

// 🌇 그림자 + 보도 렌더링
async function drawShadows(center, date){
  try {
    panel.textContent = '☀️ 데이터 불러오는 중...';
    const bounds = map.getBounds().pad(0.3);
    const data = await fetchOSM(bounds);
    const nodes = {};
    data.elements.forEach(el=>{if(el.type==='node') nodes[el.id]=[el.lon,el.lat];});

    const buildingFeatures=[];
    footwayFeatures=[];

    data.elements.forEach(el=>{
      if(el.type==='way' && (el.tags?.building || el.tags?.landuse || el.tags?.amenity)){
        const coords = el.nodes.map(i=>nodes[i]).filter(Boolean);
        if(coords.length>3){
          const f=coords[0], l=coords[coords.length-1];
          if(f[0]!==l[0] || f[1]!==l[1]) coords.push(f);
          buildingFeatures.push({
            type:'Feature',
            geometry:{type:'Polygon',coordinates:[coords]},
            properties:{height:estimateHeight(el.tags)}
          });
        }
      }
      if(el.type==='way' && el.tags?.highway){
        const coords = el.nodes.map(i=>nodes[i]).filter(Boolean);
        if(coords.length>1){
          footwayFeatures.push({
            type:'Feature',
            geometry:{type:'LineString',coordinates:coords},
            properties:{}
          });
        }
      }
    });

    const ang = sunAngles(date, center[0], center[1]);
    const shadows = computeShadows(buildingFeatures, ang.az, ang.alt);

    shadowLayer.clearLayers();
    footwayLayer.clearLayers();

    // 건물 및 그림자 표시
    L.geoJSON({type:'FeatureCollection',features:buildingFeatures},
      {style:{color:'#555',weight:1,fillOpacity:0.05}}).addTo(shadowLayer);
    shadows.forEach(s=>{
      L.geoJSON(s,{style:{color:'#000',weight:0,fillOpacity:0.5},className:'blur-shadow'}).addTo(shadowLayer);
    });

    // 보도와 그림자 교차 여부 (buffer 포함)
    footwayFeatures.forEach(fw => {
      const buffered = turf.buffer(fw, 0.00002, { units: 'kilometers' }); // 2m 폭 확장
      let inShadow = false;
      for (const sh of shadows) {
        if (turf.booleanIntersects(buffered, sh) || turf.booleanOverlap(buffered, sh)) {
          inShadow = true;
          break;
        }
      }
      L.geoJSON(fw, {
        style: {
          color: inShadow ? 'green' : '#999',
          weight: 4
        }
      }).addTo(footwayLayer);
    });

    panel.textContent = `✅ 그림자 ${buildingFeatures.length}개, 보도 ${footwayFeatures.length}개 / 고도 ${ang.alt.toFixed(1)}°`;
  } catch(err){
    console.warn('그림자 계산 오류:', err);
    panel.textContent = '⚠️ 데이터 불러오기 실패 — 지도는 정상 표시 중';
  }
}

// 📍 위치 권한 처리
function initLocation(){
  if(navigator.geolocation){
    navigator.geolocation.getCurrentPosition(pos=>{
      myLocation=[pos.coords.latitude,pos.coords.longitude];
      map.setView(myLocation,16);
      L.circleMarker(myLocation,{radius:6,color:'#0a0'}).addTo(map);
      drawShadows(myLocation, currentDate);
      map.on('moveend', ()=>drawShadows(myLocation, currentDate));
    }, err=>{
      console.warn('위치 권한 거부 또는 오류', err);
      panel.textContent = '📌 위치 권한 없음 — 기본 위치(서울)';
      drawShadows(DEFAULT_LOC, currentDate);
      map.on('moveend', ()=>drawShadows(DEFAULT_LOC, currentDate));
    }, {enableHighAccuracy:true, timeout:8000});
  } else {
    panel.textContent = '📌 위치 정보 미지원 — 기본 위치(서울)';
    drawShadows(DEFAULT_LOC, currentDate);
    map.on('moveend', ()=>drawShadows(DEFAULT_LOC, currentDate));
  }
}

// ⏰ 시간 조절 기능
function getSelectedDate() {
  const d = new Date();
  if (timePicker.value) {
    const [h, m] = timePicker.value.split(':');
    d.setHours(parseInt(h), parseInt(m));
  }
  return d;
}
timePicker.addEventListener('input', ()=>{
  currentDate = getSelectedDate();
  drawShadows(myLocation || DEFAULT_LOC, currentDate);
});
nowBtn.addEventListener('click', ()=>{
  timePicker.value = '';
  currentDate = new Date();
  drawShadows(myLocation || DEFAULT_LOC, currentDate);
});

initLocation();
</script>
</body>
</html>
