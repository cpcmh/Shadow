<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>ğŸŒ¤ï¸ ì‹¤ì‹œê°„ ê·¸ë¦¼ì ì§€ë„ (ì•„íŒŒíŠ¸Â·í•™êµ multipolygon ëŒ€ì‘)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
html,body,#map{height:100%;margin:0;padding:0;}
.blur-shadow{filter:blur(3px);opacity:0.45;}
#panel{
  position:absolute;top:10px;left:10px;z-index:9999;
  background:rgba(255,255,255,0.95);padding:8px 12px;
  border-radius:12px;box-shadow:0 2px 6px rgba(0,0,0,0.25);
  font-size:14px;max-width:90vw;
}
</style>
</head>
<body>
<div id="map"></div>
<div id="panel">ê·¸ë¦¼ìë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<script>
const map = L.map('map');
const panel = document.getElementById('panel');
const shadowLayer = L.layerGroup().addTo(map);

let myLocation = null;
const DEFAULT_LOC = [37.5665,126.9780]; // ì„œìš¸ ì‹œì²­

// ---------- SunCalc ----------
function sunAngles(date, lat, lon){
  const p = SunCalc.getPosition(date, lat, lon);
  return { az: (180 + p.azimuth*180/Math.PI)%360, alt: p.altitude*180/Math.PI };
}

// ---------- ë†’ì´ ì¶”ì • ----------
function estimateHeight(tags={}){
  if(tags.height) return parseFloat(tags.height);
  if(tags["building:levels"]) return parseFloat(tags["building:levels"])*3;
  if(tags.amenity === 'school') return 20;
  if(tags.amenity === 'university' || tags.amenity === 'college') return 22;
  if(tags.landuse === 'residential') return 50;     // ì•„íŒŒíŠ¸ ë‹¨ì§€
  if(tags.landuse === 'commercial' || tags.landuse==='retail') return 30;
  if(tags.landuse === 'industrial') return 18;
  return 12; // ê¸°ë³¸
}

// ---------- ê·¸ë¦¼ì ìƒì„± ----------
function computeShadows(polys, trees, az, alt){
  if(alt<=0) return [];
  const tanAlt = Math.tan(alt*Math.PI/180);
  const dir = (az+180)%360;
  const out = [];
  for(const f of polys){
    const h = f.properties.height || 12;
    try{
      out.push(turf.transformTranslate(f, h/tanAlt/1000, dir, {units:'kilometers'}));
    }catch(e){}
  }
  for(const t of trees){
    const h = t.properties.height || 8;
    const r = (t.properties.crown_diameter || 5)/111000; // ~mâ†’deg via turf.buffer (km ë‹¨ìœ„ë¡œë„ ê°€ëŠ¥í•˜ì§€ë§Œ ê°„ë‹¨í™”)
    try{
      const circ = turf.buffer(t, r);
      out.push(turf.transformTranslate(circ, h/tanAlt/1000, dir, {units:'kilometers'}));
    }catch(e){}
  }
  return out;
}

// ---------- Overpass ----------
async function fetchOSM(bounds){
  const s=bounds.getSouth(), w=bounds.getWest(), n=bounds.getNorth(), e=bounds.getEast();

  // í•µì‹¬: relation(ì•„íŒŒíŠ¸/í•™êµ) â†’ outer way â†’ node ë¡œ ì¡°ë¦½í•˜ê¸° ìœ„í•´
  // relations, ways, nodesë¥¼ ëª¨ë‘ í•œ ë²ˆì— ë°›ì•„ì˜¨ë‹¤.
  const q = `
  [out:json][timeout:60];
  (
    // ì¼ë°˜ ê±´ë¬¼
    way["building"](${s},${w},${n},${e});
    // ë¶€ì§€(ì•„íŒŒíŠ¸Â·ìƒì—…Â·í•™êµ ë“±) - way
    way["landuse"~"residential|commercial|retail|industrial"](${s},${w},${n},${e});
    way["amenity"~"school|college|university"](${s},${w},${n},${e});

    // ë¶€ì§€(ì•„íŒŒíŠ¸Â·í•™êµ ë“±) - relation (multipolygon)
    relation["landuse"~"residential|commercial|retail|industrial"](${s},${w},${n},${e});
    relation["amenity"~"school|college|university"](${s},${w},${n},${e});

    // ë‚˜ë¬´
    node["natural"="tree"](${s},${w},${n},${e});
  );
  out body;
  >;
  out skel qt;`;

  const res = await fetch('https://overpass-api.de/api/interpreter',{method:'POST', body:q});
  if(!res.ok) throw new Error('Overpass ì˜¤ë¥˜: '+res.status);
  return res.json();
}

// ---------- Relation(outer ways) â†’ ë‹«íŒ í´ë¦¬ê³¤ ë§ ì¡°ë¦½ ----------
function assembleRelationPolygons(rel, waysMap, nodesMap){
  // outer waysë§Œ ìˆ˜ì§‘
  const outerWays = rel.members.filter(m=>m.role==='outer' && m.type==='way' && waysMap[m.ref]);
  if(!outerWays.length) return [];

  // ê° wayë¥¼ ë…¸ë“œ ID ì‹œí€€ìŠ¤ë¡œ ì¤€ë¹„
  const segments = outerWays.map(m=>{
    const w = waysMap[m.ref];
    return w.nodes.slice(); // node ID ë°°ì—´
  });

  // ë§ì„ ë§Œë“¤ê¸° ìœ„í•´ ëì ì´ ë§ë‹¿ëŠ” ì„¸ê·¸ë¨¼íŠ¸ë“¤ì„ ì´ì–´ë¶™ì¸ë‹¤.
  const rings = [];
  while(segments.length){
    let ring = segments.shift();
    let extended = true;
    while(extended){
      extended = false;
      for(let i=0;i<segments.length;i++){
        const seg = segments[i];
        const aStart = ring[0], aEnd = ring[ring.length-1];
        const bStart = seg[0],  bEnd = seg[seg.length-1];

        if(aEnd === bStart){
          // ...A ---- B...
          ring = ring.concat(seg.slice(1));
          segments.splice(i,1);
          extended = true; break;
        } else if(aEnd === bEnd){
          // ...A ==== B...
          ring = ring.concat(seg.slice(0,-1).reverse());
          segments.splice(i,1);
          extended = true; break;
        } else if(aStart === bEnd){
          // B... ==== ...A
          ring = seg.concat(ring.slice(1));
          segments.splice(i,1);
          extended = true; break;
        } else if(aStart === bStart){
          // B... ---- ...A (ë’¤ì§‘ì–´ì„œ ì—°ê²°)
          ring = seg.reverse().concat(ring.slice(1));
          segments.splice(i,1);
          extended = true; break;
        }
      }
    }
    // ë‹«íŒì§€ í™•ì¸ (ì²«/ë ë…¸ë“œ ë™ì¼)
    if(ring.length>=4 && ring[0] === ring[ring.length-1]){
      rings.push(ring);
    } else {
      // ì¼ë¶€ relationì€ ì™„ì „íˆ ë‹«íˆì§€ ì•Šì„ ìˆ˜ ìˆìŒ â†’ ë¬´ì‹œ
    }
  }

  // node id â†’ lon/lat
  const polys = rings.map(ring=>{
    const coords = ring.map(nid => nodesMap[nid]).filter(Boolean);
    // ì¢Œí‘œ ëˆ„ë½ì‹œ ë¬´ì‹œ
    if(coords.length === ring.length) {
      return coords;
    }
    return null;
  }).filter(Boolean);

  return polys;
}

// ---------- ê·¸ë¦¼ì ê·¸ë¦¬ê¸° ----------
async function drawShadows(centerLatLng){
  try{
    panel.textContent = 'ê·¸ë¦¼ì ê³„ì‚° ì¤‘...';
    const bounds = map.getBounds().pad(0.3);
    const data = await fetchOSM(bounds);

    // ë§µ
    const nodes = {};      // id -> [lon,lat]
    const ways = {};       // id -> way element
    const relations = [];  // relation elements
    const trees = [];

    for(const el of data.elements){
      if(el.type==='node'){
        nodes[el.id] = [el.lon, el.lat];
        if(el.tags && el.tags.natural==='tree'){
          trees.push({
            type:'Feature',
            geometry:{type:'Point', coordinates:[el.lon, el.lat]},
            properties:{
              height: parseFloat(el.tags.height)||8,
              crown_diameter: parseFloat(el.tags['crown_diameter'])||5
            }
          });
        }
      } else if(el.type==='way'){
        ways[el.id] = el;
      } else if(el.type==='relation'){
        relations.push(el);
      }
    }

    // í´ë¦¬ê³¤ í›„ë³´(ê±´ë¬¼+ë¶€ì§€)
    const polys = [];

    // 1) way ê¸°ë°˜ í´ë¦¬ê³¤
    for(const id in ways){
      const w = ways[id];
      const tags = w.tags||{};
      if(!(tags.building || tags.landuse || tags.amenity)) continue;
      const coords = (w.nodes||[]).map(nid=>nodes[nid]).filter(Boolean);
      if(coords.length>=3){
        // ë‹«í˜€ìˆì§€ ì•Šìœ¼ë©´ ë‹«ê¸°
        const first = coords[0], last = coords[coords.length-1];
        if(first[0]!==last[0] || first[1]!==last[1]) coords.push(first);
        polys.push({
          type:'Feature',
          geometry:{type:'Polygon', coordinates:[coords]},
          properties:{height: estimateHeight(tags)}
        });
      }
    }

    // 2) relation ê¸°ë°˜ multipolygon(ì•„íŒŒíŠ¸/í•™êµ ë“±)
    for(const rel of relations){
      const tags = rel.tags||{};
      if(!(tags.landuse || tags.amenity)) continue;
      const outerPolys = assembleRelationPolygons(rel, ways, nodes);
      for(const ring of outerPolys){
        polys.push({
          type:'Feature',
          geometry:{type:'Polygon', coordinates:[ring]},
          properties:{height: estimateHeight(tags)}
        });
      }
    }

    // Sun ìœ„ì¹˜
    const now = new Date();
    const ang = sunAngles(now, centerLatLng[0], centerLatLng[1]);

    // ê·¸ë¦¼ì ìƒì„±
    const shadows = computeShadows(polys, trees, ang.az, ang.alt);

    // í‘œì‹œ
    shadowLayer.clearLayers();
    // (ë””ë²„ê·¸ìš©) ë³¸ì²´ ìœ¤ê³½ ì‚´ì§
    L.geoJSON({type:'FeatureCollection',features:polys},{style:{color:'#666',weight:1,fillOpacity:0.06}}).addTo(shadowLayer);
    // ê·¸ë¦¼ì
    shadows.forEach(s=>{
      L.geoJSON(s,{style:{color:'#000',weight:0,fillOpacity:0.45},className:'blur-shadow'}).addTo(shadowLayer);
    });

    panel.textContent = (myLocation
      ? 'ğŸ“ í˜„ì¬ ìœ„ì¹˜ ê¸°ì¤€ ê·¸ë¦¼ì í‘œì‹œ ì™„ë£Œ'
      : 'ğŸ“Œ ê¸°ë³¸ ìœ„ì¹˜(ì„œìš¸) ê¸°ì¤€ ê·¸ë¦¼ì í‘œì‹œ ì™„ë£Œ')
      + ` â€¢ ${polys.length}ê°œ í´ë¦¬ê³¤ / ë‚˜ë¬´ ${trees.length}ê°œ`;
  }catch(e){
    console.error(e);
    panel.textContent = 'ê·¸ë¦¼ì ë¡œë”© ì‹¤íŒ¨: ' + (e.message||e);
  }
}

// ---------- ìœ„ì¹˜ ----------
function initLocation(){
  if(navigator.geolocation){
    navigator.geolocation.getCurrentPosition(pos=>{
      myLocation=[pos.coords.latitude,pos.coords.longitude];
      map.setView(myLocation,16);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);
      L.circleMarker(myLocation,{radius:6,color:'#0a0'}).addTo(map);
      drawShadows(myLocation);
      map.on('moveend', ()=>drawShadows(myLocation));
    }, err=>{
      // ê¶Œí•œ ì—†ì–´ë„ ê¸°ë³¸ ìœ„ì¹˜ë¡œ ê·¸ë¦¼ì í‘œì‹œ (ë¨¹í†µ ë°©ì§€)
      map.setView(DEFAULT_LOC,16);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);
      panel.textContent = 'ìœ„ì¹˜ ê¶Œí•œ ì—†ìŒ â†’ ì„œìš¸ ê¸°ì¤€ ê·¸ë¦¼ì í‘œì‹œ';
      drawShadows(DEFAULT_LOC);
      map.on('moveend', ()=>drawShadows(DEFAULT_LOC));
    }, {enableHighAccuracy:true, timeout:15000});
  } else {
    map.setView(DEFAULT_LOC,16);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);
    panel.textContent = 'ìœ„ì¹˜ ì •ë³´ ë¯¸ì§€ì› â†’ ì„œìš¸ ê¸°ì¤€ ê·¸ë¦¼ì í‘œì‹œ';
    drawShadows(DEFAULT_LOC);
    map.on('moveend', ()=>drawShadows(DEFAULT_LOC));
  }
}

initLocation();
</script>
</body>
</html>
