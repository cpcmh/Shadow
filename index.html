<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>ğŸŒ³ ê·¸ëŠ˜ì§€ë„ (ë³´í–‰ì ì¤‘ì‹¬)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="manifest" href="./manifest.json" />
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./service-worker.js');
}
</script>
<style>
html, body, #map { height: 100%; margin: 0; padding: 0; }
#panel {
  position: absolute; top: 10px; left: 10px;
  z-index: 9999; background: rgba(255,255,255,0.95);
  padding: 8px 12px; border-radius: 12px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  font-size: 14px;
}
#timeControl {
  position: absolute; top: 10px; right: 10px;
  z-index: 9999; background: rgba(255,255,255,0.95);
  padding: 6px 10px; border-radius: 12px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  font-size: 14px;
}
#locBtn {
  position: absolute; bottom: 20px; left: 50%;
  transform: translateX(-50%);
  z-index: 9999; padding: 10px 20px;
  background: #1a73e8; color: #fff;
  border: none; border-radius: 25px;
  font-size: 16px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
}
.blur-shadow { filter: blur(3px); opacity: 0.45; }
</style>
</head>
<body>
<div id="map"></div>
<div id="panel">ğŸ“¡ ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜¤ë ¤ë©´ ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”</div>
<div id="timeControl">
  <label for="timeInput">ì‹œê°„:</label>
  <input type="time" id="timeInput" step="900">
</div>
<button id="locBtn">ğŸ“ ë‚´ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°</button>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<script>
const panel = document.getElementById('panel');
const shadowLayer = L.layerGroup();
const footwayLayer = L.layerGroup();
const map = L.map('map');
shadowLayer.addTo(map);
footwayLayer.addTo(map);

const defaultLocation = [37.5665, 126.9780]; // ì„œìš¸ì‹œì²­ ì¢Œí‘œ
let myLocation = null;
let selectedTime = new Date();

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap'
}).addTo(map);

map.setView(defaultLocation, 16);

function getSunAngles(date, lat, lon){
  const pos = SunCalc.getPosition(date, lat, lon);
  return { azimuth: (180+pos.azimuth*180/Math.PI)%360, altitude: pos.altitude*180/Math.PI };
}

function computeShadow(buildings, trees, az, alt){
  if(alt <= 0) return [];
  const tanAlt = Math.tan(alt*Math.PI/180);
  const sunDir = (az+180)%360;
  const shadows = [];
  buildings.forEach(b=>{
    const h = b.properties.height || 12;
    shadows.push(turf.transformTranslate(b,h/tanAlt/1000,sunDir,{units:'kilometers'}));
  });
  trees.forEach(t=>{
    const h = t.properties.height || 8;
    const r = (t.properties.crown_diameter || 5)/111000;
    shadows.push(turf.transformTranslate(turf.buffer(t,r),h/tanAlt/1000,sunDir,{units:'kilometers'}));
  });
  return shadows;
}

async function fetchOSM(bounds){
  const s=bounds.getSouth(), w=bounds.getWest(), n=bounds.getNorth(), e=bounds.getEast();
  const q = `[out:json][timeout:25];
  (way["building"](${s},${w},${n},${e});
   node["natural"="tree"](${s},${w},${n},${e}););
  out body; >; out skel qt;`;
  const res = await fetch("https://overpass-api.de/api/interpreter",{method:"POST",body:q});
  return res.json();
}

async function fetchFootways(bounds){
  const s=bounds.getSouth(), w=bounds.getWest(), n=bounds.getNorth(), e=bounds.getEast();
  const q = `[out:json][timeout:25];
  way["highway"="footway"](${s},${w},${n},${e});
  out body; >; out skel qt;`;
  const res = await fetch("https://overpass-api.de/api/interpreter",{method:"POST",body:q});
  return res.json();
}

async function drawShadows(center){
  const bounds = map.getBounds().pad(0.3);
  const data = await fetchOSM(bounds);
  if(!data) return;

  const nodes = {};
  data.elements.forEach(el=>{ if(el.type==='node') nodes[el.id]=[el.lon,el.lat]; });

  const buildings=[], trees=[];
  data.elements.forEach(el=>{
    if(el.type==='way' && el.tags?.building){
      const coords = el.nodes.map(i=>nodes[i]).filter(Boolean);
      if(coords.length>3)
        buildings.push({type:'Feature',geometry:{type:'Polygon',coordinates:[coords]},properties:{height:parseFloat(el.tags.height)||12}});
    } else if(el.type==='node' && el.tags?.natural==='tree'){
      trees.push({type:'Feature',geometry:{type:'Point',coordinates:[el.lon,el.lat]},
        properties:{height:parseFloat(el.tags.height)||8,crown_diameter:parseFloat(el.tags["crown_diameter"])||5}});
    }
  });

  const ang = getSunAngles(selectedTime, center[0], center[1]);
  const shadows = computeShadow(buildings, trees, ang.azimuth, ang.altitude);

  shadowLayer.clearLayers();
  shadows.forEach(s=>{
    L.geoJSON(s,{style:{color:'#000',weight:0,fillOpacity:0.45},className:'blur-shadow'}).addTo(shadowLayer);
  });

  panel.textContent = `â˜€ï¸ ê·¸ë¦¼ì í‘œì‹œ ì™„ë£Œ (${selectedTime.toLocaleTimeString('ko-KR',{hour:'2-digit',minute:'2-digit'})})`;

  drawFootways(bounds, shadows);
}

async function drawFootways(bounds, shadows){
  const data = await fetchFootways(bounds);
  const nodes = {};
  data.elements.forEach(el=>{ if(el.type==='node') nodes[el.id]=[el.lon,el.lat]; });

  const footways=[];
  data.elements.forEach(el=>{
    if(el.type==='way'){
      const coords = el.nodes.map(i=>nodes[i]).filter(Boolean);
      if(coords.length>1)
        footways.push({type:'Feature',geometry:{type:'LineString',coordinates:coords},properties:{}});
    }
  });

  footwayLayer.clearLayers();
  footways.forEach(fw=>{
    let shaded = false;
    shadows.forEach(sh=>{
      if(turf.intersect(sh, turf.buffer(fw, 0.00001))) shaded = true;
    });
    L.geoJSON(fw,{
      style:{
        color: shaded ? '#2ecc71' : '#b0b0b0',
        weight: shaded ? 5 : 2
      }
    }).addTo(footwayLayer);
  });
}

document.getElementById('locBtn').addEventListener('click', ()=>{
  if(navigator.geolocation){
    navigator.geolocation.getCurrentPosition(pos=>{
      myLocation=[pos.coords.latitude,pos.coords.longitude];
      map.setView(myLocation, 16);
      L.circleMarker(myLocation,{radius:6,color:'#0a0'}).addTo(map);
      drawShadows(myLocation);
    },err=>{
      alert("âš ï¸ ìœ„ì¹˜ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ê¸°ë³¸ ìœ„ì¹˜ë¡œ í‘œì‹œë©ë‹ˆë‹¤.");
      drawShadows(defaultLocation);
    },{enableHighAccuracy:true});
  } else {
    alert("âš ï¸ ì´ ê¸°ê¸°ëŠ” ìœ„ì¹˜ ì •ë³´ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    drawShadows(defaultLocation);
  }
});

const timeInput = document.getElementById('timeInput');
function initTime(){
  const now = new Date();
  timeInput.value = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
}
timeInput.addEventListener('change', ()=>{
  const [h,m] = timeInput.value.split(':').map(Number);
  selectedTime.setHours(h); selectedTime.setMinutes(m);
  drawShadows(myLocation || defaultLocation);
});
initTime();

map.on('moveend', ()=> drawShadows(myLocation || defaultLocation));
</script>
</body>
</html>
