<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>ğŸŒ‡ ì‹¤ì‹œê°„ ê·¸ë¦¼ì ì§€ë„ - í†µí•©ë²„ì „</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
html,body,#map{height:100%;margin:0;padding:0;}
.blur-shadow{filter:blur(3px);opacity:0.45;}
#panel{
  position:absolute;top:10px;left:10px;z-index:9999;
  background:rgba(255,255,255,0.95);
  padding:8px 12px;border-radius:12px;
  box-shadow:0 2px 6px rgba(0,0,0,0.25);
  font-size:14px;max-width:90vw;
}
#timeControl {
  position: absolute;
  top: 10px;
  right: 10px;
  z-index: 9999;
  background: rgba(255, 255, 255, 0.95);
  padding: 8px 12px;
  border-radius: 12px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  font-size: 14px;
  display: flex;
  gap: 5px;
  flex-wrap: wrap;
}
#timePicker {
  font-size: 14px;
  padding: 2px;
}
#nowBtn {
  font-size: 13px;
  padding: 3px 6px;
  cursor: pointer;
}
</style>
</head>
<body>
<div id="map"></div>
<div id="panel">ì§€ë„ ë¡œë”© ì¤‘...</div>

<!-- ğŸ•’ ì‹œê°„ ì¡°ì ˆ UI -->
<div id="timeControl">
  <label for="timePicker">ì‹œê°„ ì¡°ì •:</label>
  <input type="time" id="timePicker" step="300">
  <button id="nowBtn">ì§€ê¸ˆ ì‹œê°„</button>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<script>
const panel = document.getElementById('panel');
const timePicker = document.getElementById('timePicker');
const nowBtn = document.getElementById('nowBtn');

const DEFAULT_LOC = [37.5665, 126.9780]; // ì„œìš¸
let myLocation = null;
let currentDate = new Date();

const map = L.map('map');
const shadowLayer = L.layerGroup().addTo(map);

// ğŸ—ºï¸ ì•ˆì •ì ì¸ íƒ€ì¼ ì„œë²„
L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap, Carto'
}).on('tileerror',()=>{
  panel.textContent = 'âš ï¸ íƒ€ì¼ ë¡œë“œ ì‹¤íŒ¨ â€” ë„¤íŠ¸ì›Œí¬ ë˜ëŠ” ì°¨ë‹¨ ê°€ëŠ¥ì„±';
}).addTo(map);

// â˜€ï¸ íƒœì–‘ ìœ„ì¹˜ ê³„ì‚°
function sunAngles(date, lat, lon){
  const p = SunCalc.getPosition(date, lat, lon);
  return { az: (180 + p.azimuth * 180/Math.PI)%360, alt: p.altitude*180/Math.PI };
}

// ğŸ¢ ê¸°ë³¸ ë†’ì´ ì¶”ì •
function estimateHeight(tags={}){
  if(tags.height) return parseFloat(tags.height);
  if(tags["building:levels"]) return parseFloat(tags["building:levels"])*3;
  if(tags.amenity === 'school') return 20;
  if(tags.landuse === 'residential') return 50;
  return 12;
}

// ğŸ¢ ê·¸ë¦¼ì ê³„ì‚°
function computeShadows(polys, az, alt){
  if(alt<=0) return [];
  const tanAlt = Math.tan(alt*Math.PI/180);
  const dir = (az+180)%360;
  const out=[];
  for(const f of polys){
    const h = f.properties.height || 12;
    try {
      out.push(turf.transformTranslate(f, h/tanAlt/1000, dir, {units:'kilometers'}));
    } catch(e){
      console.error('Shadow projection error', e);
    }
  }
  return out;
}

// ğŸ§­ Overpass í˜¸ì¶œ
async function fetchOSM(bounds){
  const s=bounds.getSouth(), w=bounds.getWest(), n=bounds.getNorth(), e=bounds.getEast();
  const q = `
  [out:json][timeout:25];
  (
    way["building"](${s},${w},${n},${e});
    way["landuse"~"residential|commercial"](${s},${w},${n},${e});
    way["amenity"="school"](${s},${w},${n},${e});
  );
  out body; >; out skel qt;
  `;
  const res = await fetch('https://overpass-api.de/api/interpreter',{method:'POST',body:q});
  if(!res.ok) throw new Error('Overpass API ì˜¤ë¥˜');
  return res.json();
}

// ğŸŒ‡ ê·¸ë¦¼ì ë Œë”ë§
async function drawShadows(center, date){
  try {
    panel.textContent = 'ê·¸ë¦¼ì ê³„ì‚° ì¤‘...';
    const bounds = map.getBounds().pad(0.3);
    const data = await fetchOSM(bounds);
    const nodes = {};
    data.elements.forEach(el=>{if(el.type==='node') nodes[el.id]=[el.lon,el.lat];});

    const features=[];
    data.elements.forEach(el=>{
      if(el.type==='way' && (el.tags?.building || el.tags?.landuse || el.tags?.amenity)){
        const coords = el.nodes.map(i=>nodes[i]).filter(Boolean);
        if(coords.length>3){
          const f=coords[0], l=coords[coords.length-1];
          if(f[0]!==l[0] || f[1]!==l[1]) coords.push(f);
          features.push({
            type:'Feature',
            geometry:{type:'Polygon',coordinates:[coords]},
            properties:{height:estimateHeight(el.tags)}
          });
        }
      }
    });

    const ang = sunAngles(date, center[0], center[1]);
    const shadows = computeShadows(features, ang.az, ang.alt);

    shadowLayer.clearLayers();
    L.geoJSON({type:'FeatureCollection',features:features},{style:{color:'#555',weight:1,fillOpacity:0.05}}).addTo(shadowLayer);
    shadows.forEach(s=>{
      L.geoJSON(s,{style:{color:'#000',weight:0,fillOpacity:0.5},className:'blur-shadow'}).addTo(shadowLayer);
    });

    panel.textContent = `âœ… ê·¸ë¦¼ì ê³„ì‚° ì™„ë£Œ (${features.length}ê°œ ê±´ë¬¼) / ê³ ë„ ${ang.alt.toFixed(2)}Â°`;
  } catch(err){
    console.error('ê·¸ë¦¼ì ê³„ì‚° ì˜¤ë¥˜:', err);
    panel.textContent = 'âš ï¸ ë°ì´í„° ë¡œë”© ì‹¤íŒ¨ â€” ì§€ë„ë¥¼ ì´ë™í•˜ê±°ë‚˜ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.';
  }
}

// ğŸ“ ìœ„ì¹˜ ê¶Œí•œ ì²˜ë¦¬
function initLocation(){
  if(navigator.geolocation){
    navigator.geolocation.getCurrentPosition(pos=>{
      myLocation=[pos.coords.latitude,pos.coords.longitude];
      map.setView(myLocation,16);
      L.circleMarker(myLocation,{radius:6,color:'#0a0'}).addTo(map);
      drawShadows(myLocation, currentDate);
      map.on('moveend', ()=>drawShadows(myLocation, currentDate));
    }, err=>{
      console.warn('ìœ„ì¹˜ ê¶Œí•œ ê±°ë¶€ ë˜ëŠ” ì˜¤ë¥˜', err);
      map.setView(DEFAULT_LOC,16);
      panel.textContent = 'ğŸ“Œ ìœ„ì¹˜ ê¶Œí•œ ì—†ìŒ â€” ê¸°ë³¸ ìœ„ì¹˜(ì„œìš¸)ë¡œ í‘œì‹œ';
      drawShadows(DEFAULT_LOC, currentDate);
      m
