<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>🌤️ 실시간 그림자 지도 (Relation 완전 처리)</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<style>
html,body,#map{height:100%;margin:0;padding:0;}
.blur-shadow{filter:blur(3px);opacity:0.45;}
#panel{
  position:absolute;top:10px;left:10px;z-index:9999;
  background:rgba(255,255,255,0.95);
  padding:8px 12px;
  border-radius:12px;
  box-shadow:0 2px 6px rgba(0,0,0,0.25);
  font-size:14px;
}
</style>
</head>
<body>
<div id="map"></div>
<div id="panel">그림자를 불러오는 중...</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<script>
const map = L.map('map');
const shadowLayer = L.layerGroup().addTo(map);
const panel = document.getElementById('panel');

let myLocation = null;
const defaultLocation = [37.5665, 126.9780];

// ☀️ 태양 위치 계산
function getSunAngles(date, lat, lon){
  const pos = SunCalc.getPosition(date, lat, lon);
  return {azimuth:(180+pos.azimuth*180/Math.PI)%360, altitude:pos.altitude*180/Math.PI};
}

// 🏢 기본 높이 추정
function estimateHeight(tags){
  if(tags.height) return parseFloat(tags.height);
  if(tags.amenity === 'school') return 20;
  if(tags.landuse === 'residential') return 50;
  if(tags.landuse === 'commercial') return 30;
  return 12;
}

// 🏢 그림자 계산
function computeShadow(features, trees, az, alt){
  if(alt<=0) return [];
  const tanAlt = Math.tan(alt*Math.PI/180);
  const sunDir = (az+180)%360;
  const shadows=[];
  features.forEach(f=>{
    const h = f.properties.height;
    shadows.push(turf.transformTranslate(f,h/tanAlt/1000,sunDir,{units:'kilometers'}));
  });
  trees.forEach(t=>{
    const h=t.properties.height||8;
    const r=(t.properties.crown_diameter||5)/111000;
    shadows.push(turf.transformTranslate(turf.buffer(t,r),h/tanAlt/1000,sunDir,{units:'kilometers'}));
  });
  return shadows;
}

// 🗺️ OSM 데이터 가져오기
async function fetchOSM(bounds){
  const s=bounds.getSouth(), w=bounds.getWest(), n=bounds.getNorth(), e=bounds.getEast();
  const q = `
    [out:json][timeout:30];
    (
      way["building"](${s},${w},${n},${e});
      way["landuse"~"residential|commercial"](${s},${w},${n},${e});
      way["amenity"="school"](${s},${w},${n},${e});
      relation["landuse"~"residential|commercial"](${s},${w},${n},${e});
      relation["amenity"="school"](${s},${w},${n},${e});
      node["natural"="tree"](${s},${w},${n},${e});
    );
    out body; >; out skel qt;
  `;
  const res = await fetch("https://overpass-api.de/api/interpreter",{method:"POST",body:q});
  return res.json();
}

// 🌳 그림자 표시
async function drawShadows(center){
  panel.textContent = '그림자 계산 중...';
  const bounds = map.getBounds().pad(0.3);
  const data = await fetchOSM(bounds);

  const nodes = {};
  const ways = {};

  data.elements.forEach(el=>{
    if(el.type==='node') nodes[el.id]=[el.lon,el.lat];
    if(el.type==='way') ways[el.id]=el;
  });

  const features=[], trees=[];

  // way 처리
  for (const id in ways){
    const el = ways[id];
    if(el.tags && (el.tags.building || el.tags.landuse || el.tags.amenity)){
      const coords = el.nodes.map(i=>nodes[i]).filter(Boolean);
      if(coords.length>3){
        features.push({
          type:'Feature',
          geometry:{type:'Polygon',coordinates:[coords]},
          properties:{height:estimateHeight(el.tags)}
        });
      }
    }
  }

  // relation 처리
  data.elements.forEach(el=>{
    if(el.type==='relation' && (el.tags?.landuse || el.tags?.amenity)){
      const outerWays = el.members.filter(m=>m.role==='outer' && ways[m.ref]);
      if(outerWays.length){
        const outerWay = ways[outerWays[0].ref]; // 첫 outer만 사용
        const coords = outerWay.nodes.map(i=>nodes[i]).filter(Boolean);
        if(coords.length>3){
          features.push({
            type:'Feature',
            geometry:{type:'Polygon',coordinates:[coords]},
            properties:{height:estimateHeight(el.tags)}
          });
        }
      }
    }
  });

  // 나무 처리
  data.elements.forEach(el=>{
    if(el.type==='node' && el.tags?.natural==='tree'){
      trees.push({
        type:'Feature',
        geometry:{type:'Point',coordinates:[el.lon,el.lat]},
        properties:{
          height:parseFloat(el.tags.height)||8,
          crown_diameter:parseFloat(el.tags["crown_diameter"])||5
        }
      });
    }
  });

  const ang = getSunAngles(new Date(), center[0], center[1]);
  const shadows = computeShadow(features, trees, ang.azimuth, ang.altitude);

  shadowLayer.clearLayers();
  shadows.forEach(s=>{
    L.geoJSON(s,{style:{color:'#000',weight:0,fillOpacity:0.45},className:'blur-shadow'}).addTo(shadowLayer);
  });

  panel.textContent = myLocation 
    ? '📍 현재 위치 기준 그림자 표시 완료'
    : '📌 기본 위치(서울) 기준 그림자 표시 완료';
}

// 📍 위치 권한 요청
function initLocation(){
  if(navigator.geolocation){
    navigator.geolocation.getCurrentPosition(pos=>{
      myLocation=[pos.coords.latitude,pos.coords.longitude];
      map.setView(myLocation,16);
      L.circleMarker(myLocation,{radius:6,color:'#0a0'}).addTo(map);
      drawShadows(myLocation);
    }, err=>{
      panel.textContent = '위치 권한 없음 → 서울 기준 그림자 표시';
      map.setView(defaultLocation,16);
      drawShadows(defaultLocation);
    }, {enableHighAccuracy:true});
  } else {
    panel.textContent = '위치 정보 미지원 → 서울 기준 그림자 표시';
    map.setView(defaultLocation,16);
    drawShadows(defaultLocation);
  }
}

initLocation();
map.on('moveend', ()=> drawShadows(myLocation || defaultLocation));
</script>
</body>
</html>
